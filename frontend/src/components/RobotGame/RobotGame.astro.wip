---
export const enum Direction {
  WAIT,
  UP,
  DOWN,
  LEFT,
  RIGHT,
}

type Props = {
  code?: string;
  rows: number;
  cols: number;
  start: number;
  enemies: {
    pos: number;
    move: Direction[];
  }[];
  id: number;
  winText: string;
  loseText: string;
};
const {
  code,
  rows,
  cols,
  start = 0,
  enemies = [],
  id,
  winText = "You win!",
  loseText = "There are some Slimes left, try again!",
} = Astro.props;

import { Image } from "astro:assets";
import CodeBlock from "@components/CodeBlock/CodeBlock.astro";
import Robot from "@assets/robot.svg";

const slimes = (
  await Astro.glob<Record<string, ImageMetadata>>(
    "/src/assets/monsters/slime/*",
  )
).map((v) => v.default!);
const getRandomSlime = () => slimes[Math.floor(Math.random() * slimes.length)]!;

const robotSize = 70;
const slimeWidth = 70;
const setup = `
struct Robot;impl Robot{fn new()->Self{Self}fn up(&self){println!("UP")}fn down(&self){println!("DOWN")}fn left(&self){println!("LEFT")}fn right(&self){println!("RIGHT")}}
__VALUE__
`.trim();
// TODO: Add validation (no ?, etc);
---

<x-robot-game
  rows={rows}
  cols={cols}
  start={start}
  enemies={JSON.stringify(enemies)}
  id={id}
  win={winText}
  lose={loseText}
>
  <table>
    {
      [...Array(rows)].map((_, i) => (
        <tr>
          {[...Array(cols)].map((_, j) => (
            <td>
              {(start == i * cols + j && (
                <Image src={Robot} width={robotSize} alt="robot" id="robot" />
              )) ||
                (enemies.find(({pos}) => pos == i * cols + j) && (
                  <Image
                    src={getRandomSlime()}
                    width={slimeWidth}
                    alt="slime"
                    id="slime"
                  />
                )) || <p>{i * cols + j}</p>}
            </td>
          ))}
        </tr>
      ))
    }
  </table>
  <CodeBlock id={id} setup={setup} code={code?.trim()} />
</x-robot-game>

<style>
  :root {
    --cellSize: 5rem;
  }
  table {
    table-layout: fixed;
    width: fit-content;
    margin-left: auto;
    margin-right: auto;
    transition: opacity 0.2s ease-in-out;
  }
  tr {
    background-color: white !important;
  }
  td {
    width: var(--cellSize);
    height: var(--cellSize);
    text-align: center;
  }
  td > :global(p) {
    opacity: 0.5;
    font-weight: bold;
  }
  #robot {
    transition: transform 0.35s ease;
  }
  #slime {
    transition: transform 0.35s ease;
  }
  .up {
    transform: translateY(-5rem);
  }
  .down {
    transform: translateY(5rem);
  }
  .right {
    transform: translateX(5rem);
  }
  .left {
    transform: translateX(-5rem);
  }
</style>

<script>
  import { confetti } from "src/utils/confetti";
  import { Direction } from "./RobotGame.astro.wip";

  function wait(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  class RobotGame extends HTMLElement {
    readonly codeblock: CodeBlock;
    readonly startingBoard: HTMLTableElement;
    readonly startPos: number;
    readonly rows: number;
    readonly cols: number;
    readonly enemies: {
      pos: number;
      move: number[];
    }[];
    readonly winText: string;
    readonly loseText: string;

    tableChanged: boolean;
    turn: number;
    robot: HTMLImageElement;

    constructor() {
      super();
      
      this.codeblock = this.querySelector<CodeBlock>("x-code-block")!;
      this.startingBoard = this.querySelector("table")!.cloneNode(
        true,
      ) as HTMLTableElement;

      this.startPos = +this.getAttribute("start")!;
      this.rows = +this.getAttribute("rows")!;
      this.cols = +this.getAttribute("cols")!;
      this.enemies = JSON.parse(this.getAttribute("enemies")!);

      this.winText = this.getAttribute("win")!;
      this.loseText = this.getAttribute("lose")!;

      this.tableChanged = false;
      this.turn = 0;

      this.robot = this.querySelector("#robot")!;
    }

    async resetBoard() {
      if (!this.tableChanged) {
        return;
      }
      this.tableChanged = false;
      this.turn = 0;

      this.querySelector("table")!.style.opacity = "0";
      await wait(200);
      this.startingBoard.style.opacity = "0";
      this.querySelector("table")!.replaceWith(
        this.startingBoard.cloneNode(true),
      );
      await wait(20);
      this.querySelector("table")!.style.opacity = "1";
      this.robot = this.querySelector("#robot")!;
      await wait(200);
    }

    connectedCallback() {
      this.codeblock.addEventListener("reset", (e) => {
        this.resetBoard();
        e.codeBlock.hideOutput();
      });
      this.codeblock.addEventListener("response", async (e) => {
        e.preventDefault();
        await this.resetBoard();

        const cells = this.querySelectorAll("td");
        let killedEnemies = 0;
        let currentPos = this.startPos;

        this.tableChanged = true;

        const setPos = async (element: Element, newPos: number, direction: string) => {
          element.classList.add(direction);
          await wait(350);
          element.classList.remove(direction);
          ({ currentPos, killedEnemies } = this.setPos(
            element,
            currentPos,
            newPos,
            cells,
            killedEnemies,
          ));
        };

        for (const c of e.response.split("\n")) {
          switch (c) {
            case "UP": {
              const newPos = currentPos - this.cols;
              if (newPos >= 0) {
                await setPos(this.robot, newPos, "up");
              }
              break;
            }
            case "DOWN": {
              const newPos = currentPos + this.cols;
              if (newPos <= cells.length) {
                await setPos(this.robot, newPos, "down");
              }
              break;
            }
            case "LEFT": {
              const newPos = currentPos - 1;
              if (currentPos % this.cols !== 0 && newPos >= 0) {
                await setPos(this.robot, newPos, "left");
              }
              break;
            }
            case "RIGHT": {
              const newPos = currentPos + 1;
              if (newPos % this.cols !== 0 && newPos <= cells.length) {
                await setPos(this.robot, newPos, "right");
              }
              break;
            }
            
            case "WAIT":
              break;

            default:
              continue;
          }
          
          this.moveEnemies(cells);
          await wait(150);
        }

        if (killedEnemies === this.enemies.length) {
          this.codeblock.setOutput(this.winText);
          this.codeblock.setSuccess();
          confetti({ count: 20 });
        } else {
          this.codeblock.setOutput(this.loseText);
          await wait(1000);
          await this.resetBoard();
        }
        this.codeblock.setRunning(false);
      });
    }

    moveEnemies(cells: NodeListOf<HTMLTableCellElement>) {
      for (const enemy of this.enemies) {
        const newPos = enemy.pos + enemy.move[this.turn % enemy.move.length - 1]!;
        enemy.pos = newPos;
        const newCell = cells[newPos]!;
        
      }
    }
    
    async move(element: Element, currentPos: number, direction: Direction, cells: NodeListOf<HTMLTableCellElement>) {
      switch (direction) {
            case Direction.UP: {
              const newPos = currentPos - this.cols;
              if (newPos >= 0) {
                await this.setPos(element, newPos, "UP", cells);
              }
              break;
            }
            case Direction.DOWN: {
              const newPos = currentPos + this.cols;
              if (newPos <= cells.length) {
                await setPos(element, newPos, "down", cells);
              }
              break;
            }
            case Direction.LEFT: {
              const newPos = currentPos - 1;
              if (currentPos % this.cols !== 0 && newPos >= 0) {
                await setPos(this.robot, newPos, "left");
              }
              break;
            }
            case Direction.RIGHT: {
              const newPos = currentPos + 1;
              if (newPos % this.cols !== 0 && newPos <= cells.length) {
                await setPos(this.robot, newPos, "right");
              }
              break;
            }
            
            case Direction.WAIT:
              break;

            default:
              break;
          }
    }

    setPos(
      element: Element,
      currentPos: number,
      newPos: number,
      cells: NodeListOf<HTMLTableCellElement>,
      killedEnemies: number,
    ): { currentPos: number; killedEnemies: number } {
      const currentCell = cells[currentPos]!;
      const newCell = cells[newPos]!;
      
      const child = newCell.firstElementChild!;
      if (child.id === "slime") {
        if (element.id === "slime") return { currentPos, killedEnemies };
        else if (element.id === "robot") killedEnemies += 1;
      }

      child.replaceWith(element);

      const newP = document.createElement("p");
      newP.textContent = currentPos.toString();
      currentCell.appendChild(newP);

      return { currentPos: newPos, killedEnemies };
    }
  }
  customElements.define("x-robot-game", RobotGame);
</script>
