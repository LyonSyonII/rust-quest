---
type Props = {
  rows: number;
  cols: number;
  start: number;
  enemies: number[];
};
const { rows, cols, start = 0, enemies = [] } = Astro.props;

import { Image } from "astro:assets";
import CodeBlock from "@components/CodeBlock/CodeBlock.astro";
import Robot from "@assets/robot.svg";

const slimes = (
  await Astro.glob<Record<string, ImageMetadata>>(
    "/src/assets/monsters/slime/*",
  )
).map((v) => v.default!);
const getRandomSlime = () => slimes[Math.floor(Math.random() * slimes.length)]!;

const isPosEq = (p1: number, [i, j]: [number, number]) => p1 == i * cols + j;
const robotSize = 70;
const slimeWidth = 70;
const cellSize = `5rem`;
---

<x-robot-game rows={rows} cols={cols} start={start} enemies={enemies}>
  <table>
    {
      [...Array(rows)].map((_, i) => (
        <tr>
          {[...Array(cols)].map((_, j) => (
            <td>
              {enemies.some((v) => isPosEq(v, [i, j])) ? (
                <Image src={getRandomSlime()} width={slimeWidth} alt="slime" id="slime" />
              ) : (
                <b>{i*cols + j}</b>
              )}
            </td>
          ))}
        </tr>
      ))
    }
  </table>
  <Image src={Robot} width={robotSize} alt="robot" id="robot" />
  <CodeBlock />
</x-robot-game>

<style define:vars={{ robotSize, cellSize }}>
  table {
    table-layout: fixed;
    width: fit-content;
    margin-left: auto;
    margin-right: auto;
  }
  tr {
    background-color: white !important;
  }
  td {
    width: var(--cellSize);
    height: var(--cellSize);
    text-align: center;
  }
  b {
    opacity: 0.5;
  }
  #robot {
    transition: transform 0.5s ease;
    position: absolute;
  }
</style>

<script>
  class RobotGame extends HTMLElement {
    readonly robot: HTMLImageElement;
    readonly cells: NodeListOf<HTMLTableCellElement>;
    readonly rows: number;
    readonly cols: number;
    currentCell: number;

    constructor() {
      super();

      this.cells = this.querySelectorAll("td");
      this.robot = this.querySelector("#robot")!;
      this.rows = +this.getAttribute("rows")!;
      this.cols = +this.getAttribute("cols")!;
      this.currentCell = +this.getAttribute("start")!;
      // this.setPos(this.currentCell);

      const codeblock: CodeBlock =
        this.querySelector<CodeBlock>("x-code-block")!;
      codeblock?.addEventListener("response", async (e) => {
        e.preventDefault();
        for (const c of e.response.split("\n")) {
          switch (c) {
            case "UP":
              this.up();
          }
          await new Promise((resolve) => setTimeout(resolve, 250));
        }
      });
    }

    up() {
      if (this.currentCell - this.cols < 0) return;
      this.setPos(this.currentCell - this.cols);
    }

    setPos(cell: number) {
      // this.cells[this.currentCell]!.innerHTML = `<b>${this.currentCell}</b>`;
      this.currentCell = cell;
      // i*c + j
      const rect = this.cells[cell]!.getBoundingClientRect();
      this.robot.style.top = rect.top + window.scrollY + "px";
      this.robot.style.left = rect.left + "px";
    }
  }
  customElements.define("x-robot-game", RobotGame);
</script>
