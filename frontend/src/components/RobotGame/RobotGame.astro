---
import { Functions, type Board, type RobotGameProps } from "./RobotGame";
import { Image } from "astro:assets";
import CodeBlock from "@components/CodeBlock/CodeBlock.astro";
import Robot from "@assets/robot.svg";
import QuestionCard from "@components/QuestionCard.astro";

type Props = {
  question: string;
  id: string;
  cellSize: string;
};

const { question, id, cellSize = "5rem" } = Astro.props;

const {
  rows: rowsDef = 3,
  cols: colsDef = 3,
  boards,
}: RobotGameProps = await import(`src/validation/${id}.ts`);

const slimes = (
  await Astro.glob<Record<string, ImageMetadata>>(
    "/src/assets/monsters/slime/*",
  )
).map((v) => v.default!);
const getRandomSlime = () => slimes[Math.floor(Math.random() * slimes.length)]!;
---

<QuestionCard question={question}>
  <x-robot-game id={id}>
    <div id="boards">
      {
        boards.map(({ rows = rowsDef, cols = colsDef, start, enemies }) => (
          <table>
            {[...Array(cols)].map((_, i) => (
              <tr>
                {[...Array(rows)].map((_, j) => (
                  <td>
                    {(start == i * colsDef + j && (
                      <Image src={Robot} alt="robot" id="robot" />
                    )) ||
                      (enemies.includes(i * colsDef + j) && (
                        <Image src={getRandomSlime()} alt="slime" id="slime" />
                      )) || <p>{i * colsDef + j}</p>}
                  </td>
                ))}
              </tr>
            ))}
          </table>
        ))
      }
    </div>
    <CodeBlock id={id} />
  </x-robot-game>
</QuestionCard>

<style define:vars={{ cellSize }}>
  :root {
  }
  img {
    width: 80%;
    height: 80%;
    margin-left: auto;
    margin-right: auto;
  }
  table {
    table-layout: fixed;
    width: fit-content;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 1rem;
    margin-top: 0 !important;
    transition: opacity 0.2s ease-in-out;
  }
  #boards {
    display: flex;
    justify-content: space-around;
    align-items: center;
    flex-wrap: wrap;
  }
  tr {
    background-color: white !important;
  }
  td {
    width: var(--cellSize);
    height: var(--cellSize);
    padding: 0 !important;
    text-align: center;
  }
  td > :global(p) {
    opacity: 0.5;
    font-weight: bold;
  }
  #robot {
    transition: transform 0.35s ease-out;
  }
  .up {
    transform: translateY(-5rem);
  }
  .down {
    transform: translateY(5rem);
  }
  .right {
    transform: translateX(5rem);
  }
  .left {
    transform: translateX(-5rem);
  }
</style>

<script>
  import { confetti } from "src/utils/confetti";
  import type { CodeBlock } from "@components/CodeBlock/CodeBlock";
  import { Functions, type Board, type RobotGameProps } from "./RobotGame";
  import type { CodeQuestion } from "src/validation/CodeQuestion";

  type Boards = (Board & { board: HTMLTableElement, robot: HTMLImageElement, tableChanged: boolean })[];

  class RobotGame extends HTMLElement {
    readonly codeblock: CodeBlock;
    currentBoard: number = 0;
    boards: Boards = [];
    functions: Functions = Functions.BASIC;
    solveWithMinimum: boolean = false;
    winText: string = "You win!";
    loseText: string = "There are some Slimes left, try again!";

    constructor() {
      super();

      this.codeblock = this.querySelector<CodeBlock>("x-code-block")!;

      import(`src/validation/${this.id}.ts`).then((props: RobotGameProps) => {
        this.functions = props.functions || this.functions;
        this.winText = props.winText || this.winText;
        this.loseText = props.loseText || this.loseText;
        this.solveWithMinimum = props.solveWithMinimum || this.solveWithMinimum;

        const htmlBoards = [...this.querySelectorAll("table")].map(board => board.cloneNode(true) as HTMLTableElement);
      })

      this.boards = this.getAttribute("boards");

      this.startingBoard = this.querySelector("table")!.cloneNode(
        true,
      ) as HTMLTableElement;
      
      this.setupCodeBlock();
    }

    async setupCodeBlock(
      rows: number,
      cols: number,
      startPos: number,
      enemies: number[],
      functions: Functions
    ) {
      const questions = await import("src/validation/0-robot");

      let question;
      switch (functions) {
        case Functions.BASIC:
          question = questions.basicMovement;
          break;
        case Functions.LOOK_HORIZONTAL:
          question = questions.lookLeftRight(rows, cols, startPos, enemies);
          break;
        default:
          question = questions.default;
          break;
      }
      this.codeblock.setProps(question);
    }

    async resetBoard() {
      if (!this.tableChanged) {
        return;
      }
      this.tableChanged = false;
      this.querySelector("table")!.style.opacity = "0";
      await new Promise((r) => setTimeout(r, 200));
      this.startingBoard.style.opacity = "0";
      this.querySelector("table")!.replaceWith(
        this.startingBoard.cloneNode(true),
      );
      await new Promise((r) => setTimeout(r, 10));
      this.querySelector("table")!.style.opacity = "1";
      this.robot = this.querySelector("#robot")!;
      await new Promise((r) => setTimeout(r, 200));
    }

    connectedCallback() {
      this.codeblock.addEventListener("reset", (e) => {
        this.resetBoard();
        e.codeBlock.hideOutput();
      });
      this.codeblock.addEventListener("response", async (e) => {
        e.preventDefault();
        await this.resetBoard();

        const cells = this.querySelectorAll("td");
        let killedEnemies = 0;
        let currentPos = this.startPos;

        const wait = async (ms: number) =>
          new Promise((resolve) => setTimeout(resolve, ms));

        const setPos = async (newPos: number, direction: string) => {
          this.tableChanged = true;
          this.robot.classList.add(direction);
          await wait(350);
          this.robot.classList.remove(direction);
          ({ currentPos, killedEnemies } = this.setPos(
            currentPos,
            newPos,
            cells,
            killedEnemies,
          ));
        };

        for (const c of e.response.split("\n")) {
          switch (c) {
            case "UP": {
              const newPos = currentPos - this.cols;
              if (newPos >= 0) {
                await setPos(newPos, "up");
              }
              break;
            }
            case "DOWN": {
              const newPos = currentPos + this.cols;
              if (newPos <= cells.length) {
                await setPos(newPos, "down");
              }
              break;
            }
            case "LEFT": {
              const newPos = currentPos - 1;
              if (currentPos % this.cols !== 0 && newPos >= 0) {
                await setPos(newPos, "left");
              }
              break;
            }
            case "RIGHT": {
              const newPos = currentPos + 1;
              if (newPos % this.cols !== 0 && newPos <= cells.length) {
                await setPos(newPos, "right");
              }
              break;
            }

            default:
              continue;
          }

          await wait(150);
        }

        if (killedEnemies === this.enemies) {
          this.codeblock.setOutput(this.winText + "SUCCESS");
          confetti({ count: 20 });
        } else {
          this.codeblock.setOutput(this.loseText);
          await wait(1000);
          this.resetBoard();
        }
        this.codeblock.setRunning(false);
      });
    }

    setPos(
      currentPos: number,
      newPos: number,
      cells: NodeListOf<HTMLTableCellElement>,
      killedEnemies: number,
    ): { currentPos: number; killedEnemies: number } {
      const currentCell = cells[currentPos]!;
      const newCell = cells[newPos]!;

      const child = newCell.firstElementChild!;
      if (child.id === "slime") {
        killedEnemies += 1;
      }

      child.replaceWith(this.robot);

      const newP = document.createElement("p");
      newP.textContent = currentPos.toString();
      currentCell.appendChild(newP);

      return { currentPos: newPos, killedEnemies };
    }
  }
  customElements.define("x-robot-game", RobotGame);
</script>
