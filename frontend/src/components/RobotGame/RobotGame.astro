---
type Props = {
  rows: number;
  cols: number;
  start: number;
  enemies: number[];
  id: number;
};
const { rows, cols, start = 0, enemies = [], id } = Astro.props;

import { Image } from "astro:assets";
import CodeBlock from "@components/CodeBlock/CodeBlock.astro";
import Robot from "@assets/robot.svg";

const slimes = (
  await Astro.glob<Record<string, ImageMetadata>>(
    "/src/assets/monsters/slime/*",
  )
).map((v) => v.default!);
const getRandomSlime = () => slimes[Math.floor(Math.random() * slimes.length)]!;

const robotSize = 70;
const slimeWidth = 70;
const setup = `
  fn up() { println!("UP") }
  fn down() { println!("DOWN") }
  fn left() { println!("LEFT") }
  fn right() { println!("RIGHT") }
  __VALUE__
`;
---

<x-robot-game rows={rows} cols={cols} start={start} enemies={enemies} id={id}>
  <table>
    {
      [...Array(rows)].map((_, i) => (
        <tr>
          {[...Array(cols)].map((_, j) => (
            <td>
              {
                start == (i * cols + j) && <Image src={Robot} width={robotSize} alt="robot" id="robot" />
                || enemies.includes(i * cols + j) && <Image src={getRandomSlime()} width={slimeWidth} alt="slime" id="slime" />
                || <p>{i * cols + j}</p>
              }
            </td>
          ))}
        </tr>
      ))
    }
  </table>
  <CodeBlock id={id} setup={setup} />
</x-robot-game>

<style>
  :root {
    --cellSize: 5rem;
  }
  table {
    table-layout: fixed;
    width: fit-content;
    margin-left: auto;
    margin-right: auto;
  }
  tr {
    background-color: white !important;
  }
  td {
    width: var(--cellSize);
    height: var(--cellSize);
    text-align: center;
  }
  td > :global(p) {
    opacity: 0.5;
    font-weight: bold;
  }
  #robot {
    transition: transform 0.5s ease;
  }
</style>

<script>
  import { confetti } from "src/utils/confetti";

  class RobotGame extends HTMLElement {
    readonly startingBoard: HTMLTableElement;
    readonly startPos: number;
    readonly rows: number;
    readonly cols: number;
    readonly codeblock: CodeBlock;
    readonly enemies: number;

    robot: HTMLImageElement;
    
    constructor() {
      super();

      this.startingBoard = this.querySelector("table")!.cloneNode(true) as HTMLTableElement;
      this.enemies = this.querySelectorAll("#slime").length;
      this.codeblock = this.querySelector<CodeBlock>("x-code-block")!;

      this.rows = +this.getAttribute("rows")!;
      this.cols = +this.getAttribute("cols")!;
      this.startPos = +this.getAttribute("start")!;

      this.robot = this.querySelector("#robot")!;

      this.resetBoard();
    }
    
    resetBoard() {
      this.querySelector("table")!.replaceWith(this.startingBoard.cloneNode(true));
      this.robot = this.querySelector("#robot")!;
    }
    
    connectedCallback() {
        this.codeblock.addEventListener("reset", (e) => { 
          this.resetBoard();
          e.codeBlock.hideOutput();
        });
        this.codeblock.addEventListener("response", async (e) => {        
        e.preventDefault();
        this.resetBoard();
        
        const cells = this.querySelectorAll("td");
        let killedEnemies = 0;
        let currentPos = this.startPos;
        
        const setPos = (newPos: number) => ({currentPos, killedEnemies} = this.setPos(currentPos, newPos, cells, killedEnemies));
        
        for (const c of e.response.split("\n")) {
          switch (c) {
            case "UP": {
              const newPos = currentPos - this.cols;
              if (newPos >= 0) {
                setPos(newPos);
              }
              break;
            }
            case "DOWN": {
              const newPos = currentPos + this.cols;
              if (newPos <= cells.length) {
                setPos(newPos);
              }
              break;
            }
            case "LEFT": {
              const newPos = currentPos - 1;
              if (currentPos % this.cols !== 0 && newPos >= 0) {
                setPos(newPos);
              }
              break;
            }
            case "RIGHT":
              const newPos = currentPos + 1;
              if (newPos % this.cols !== 0 && newPos <= cells.length) {
                setPos(newPos);
              }
              break;
          }
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
        
        if (killedEnemies === this.enemies) {
          this.codeblock.setOutput("You win!");
          confetti({count: 20});
        } else {
          this.codeblock.setOutput("Some Slimes are still alive. Try again!");
          this.resetBoard();
        }
      });
    }

    setPos(currentPos: number, newPos: number, cells: NodeListOf<HTMLTableCellElement>, killedEnemies: number): { currentPos: number, killedEnemies: number } {
      const currentCell = cells[currentPos]!;
      const newCell = cells[newPos]!;
      
      const child = newCell.firstElementChild!;
      if (child.id === "slime") {
        killedEnemies += 1;
      }
      
      child.replaceWith(this.robot);
      
      const newP = document.createElement("p");
      newP.textContent = currentPos.toString();
      currentCell.appendChild(newP);
      
      return { currentPos: newPos, killedEnemies };
    }
  }
  customElements.define("x-robot-game", RobotGame);
</script>
